{-|
Module      : Portage.EBuild
License     : GPL-3+
Maintainer  : haskell@gentoo.org

Functions and types related to interpreting and manipulating an ebuild,
as understood by the Portage package manager.
-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE OverloadedStrings #-}
module Portage.EBuild
        ( EBuild(..)
        , ebuildTemplate
        , showEBuild
        -- hspec exports
        , sort_iuse
        , drop_tdot
        , toHttps
        ) where

import           Portage.Dependency
import           Portage.EBuild.CabalFeature
import           Portage.EBuild.Render
import qualified Portage.Dependency.Normalize as PN

import qualified Data.Time.Clock as TC
import qualified Data.Time.Format as TC
import qualified Data.Function as F
import qualified Data.List as L
import qualified Data.List.Split as LS
import           Data.Version(Version(..))
import           Data.Maybe (catMaybes, maybeToList)
import           Hackport.Pretty

import           Network.URI
import qualified Paths_hackport(version)

#if ! MIN_VERSION_time(1,5,0)
import qualified System.Locale as TC
#endif

-- | Type representing the information contained in an @.ebuild@.
data EBuild = EBuild
    { name :: String
    , category :: String
    , hackage_name :: String -- might differ a bit (we mangle case)
    , version :: String
    , revision :: String
    , hackportVersion :: String
    , sourceURIs :: [String]
    , description :: String
    , homepage :: String
    , license :: Either String String
    , slot :: String
    , keywords :: [String]
    , iuse :: [String]
    , depend :: Dependency
    , depend_extra :: [String]
    , rdepend :: Dependency
    , rdepend_extra :: [String]
    , features :: [CabalFeature]
    , cabal_pn :: Maybe String -- ^ Just 'myOldName' if the package name contains upper characters
    , src_prepare :: [String] -- ^ raw block for src_prepare() contents
    , src_configure :: [String] -- ^ raw block for src_configure() contents
    , used_options :: [(String, String)] -- ^ hints to ebuild writers/readers
                                         --   on what hackport options were used to produce an ebuild
    }
    deriving (Show, Read, Eq)

getHackportVersion :: Version -> String
getHackportVersion Version {versionBranch=(x:s)} = foldl (\y z -> y ++ "." ++ (show z)) (show x) s
getHackportVersion Version {versionBranch=[]} = ""

-- | Generate a minimal 'EBuild' template.
ebuildTemplate :: EBuild
ebuildTemplate = EBuild {
    name = "foobar",
    category = "dev-haskell",
    hackage_name = "FooBar",
    version = "0.1",
    revision = "0",
    sourceURIs = [],
    hackportVersion = getHackportVersion Paths_hackport.version,
    description = "",
    homepage = "https://hackage.haskell.org/package/${HACKAGE_N}",
    license = Left "unassigned license?",
    slot = "0",
    keywords = [],
    iuse = [],
    depend = empty_dependency,
    depend_extra = [],
    rdepend = empty_dependency,
    rdepend_extra = [],
    features = [],
    cabal_pn = Nothing
    , src_prepare = []
    , src_configure = []
    , used_options = []
  }

-- | Pretty-print an 'EBuild' as a 'String'.
showEBuild :: TC.UTCTime -> EBuild -> String
showEBuild now ebuild = renderDoc $ vsep $
  [ "# Copyright 1999-" <> this_year <> " Gentoo Authors"
  , "# Distributed under the terms of the GNU General Public License v2"
  , emptyDoc
  , "EAPI=8"
  , emptyDoc
  , "# ebuild generated by hackport" <+> pretty (hackportVersion ebuild)
  , vsep $ map
      (\(k,v) -> "#hackport: " <> pretty k <> ": " <> pretty v)
      (used_options ebuild)
  , emptyDoc
  , beforeInherit
  , "CABAL_FEATURES=" <> dquotes (hsep (map (pretty . render) (features ebuild)))
  , "inherit haskell-cabal"
  , emptyDoc
  , "DESCRIPTION=" <> dquotes (pretty (drop_tdot (description ebuild)))
  , "HOMEPAGE=" <> dquotes (pretty (toHttps $ expandVars (homepage ebuild)))
  , emptyDoc
  , "LICENSE=" <> (either (\err -> dquotes emptyDoc <> "\t# FIXME: " <> pretty err)
                         (dquotes . pretty)
                         (license ebuild))
  , "SLOT=" <> dquotes (pretty (slot ebuild))
  , "KEYWORDS=" <> dquotes (hsep (map pretty (keywords ebuild)))
  , let iuseList = hsep $ map pretty $ sort_iuse $ L.nub $ iuse ebuild
        x = if null (iuse ebuild)
          then Nothing
          else Just $ "IUSE=" <> dquotes iuseList
       -- IUSE line if needed, then an empty line
    in vsep $ maybeToList x ++ [emptyDoc]
  , dep_str "RDEPEND" (rdepend_extra ebuild) (rdepend ebuild)
  , dep_str "DEPEND"  ( depend_extra ebuild) ( depend ebuild)
  ] ++ catMaybes
  [ verbatim
      (vsep [emptyDoc, "src_prepare() {"])
      (src_prepare ebuild)
      "}"
  , verbatim
      (vsep [emptyDoc, "src_configure() {"])
      (src_configure ebuild)
      "}"
  ]
  where
        expandVars = replaceMultiVars [ (        name ebuild, "${PN}")
                                      , (hackage_name ebuild, "${HACKAGE_N}")
                                      ]


        this_year :: Doc ann
        this_year = pretty $ TC.formatTime TC.defaultTimeLocale "%Y" now

        beforeInherit =
            let rev = revision ebuild
                mpn = cabal_pn ebuild
               -- Any needed lines then an empty line
            in vsep $ catMaybes [revLine rev, pnLine <$> mpn] ++ [emptyDoc]

        revLine "0" = Nothing
        revLine r   = Just $ hcat ["CABAL_HACKAGE_REVISION=", pretty r]

        pnLine pn = hcat ["CABAL_PN=", dquotes (pretty pn)]

-- | Convert http urls into https urls, unless whitelisted as http-only.
--
-- >>> toHttps "http://darcs.net"
-- "http://darcs.net"
-- >>> toHttps "http://pandoc.org"
-- "https://pandoc.org"
-- >>> toHttps "https://github.com"
-- "https://github.com"
toHttps :: String -> String
toHttps x =
  case parseURI x of
    Just uri -> if uriScheme uri == "http:" &&
                   (uriRegName <$> uriAuthority uri)
                   `notElem`
                   httpOnlyHomepages
                then replace "http" "https" x
                else x
    Nothing -> x
  where
    replace old new = L.intercalate new . LS.splitOn old
    -- add to this list with any non https-aware websites
    httpOnlyHomepages = Just <$> [ "leksah.org"
                                 , "darcs.net"
                                 ]

-- | Sort IUSE alphabetically
--
-- >>> sort_iuse ["+a","b"]
-- ["+a","b"]
sort_iuse :: [String] -> [String]
sort_iuse = L.sortBy (compare `F.on` dropWhile ( `elem` ("+" :: String)))

-- | Drop trailing dot(s).
--
-- >>> drop_tdot "foo."
-- "foo"
-- >>> drop_tdot "foo..."
-- "foo"
drop_tdot :: String -> String
drop_tdot = reverse . dropWhile (== '.') . reverse

verbatim :: Doc ann -> [String] -> Doc ann -> Maybe (Doc ann)
verbatim pre s post
  | null s = Nothing
  | otherwise = Just $ vsep $ [pre] ++ map (hang 1 . pretty) s ++ [post]

dep_str :: Doc ann -> [String] -> Dependency -> Doc ann
dep_str var extra dep = var <> "=" <> dquotes (hang 1 inner)
  where inner = vsep $ map pretty extra ++ [showDepend (PN.normalize_depend dep)]

getRestIfPrefix :: String       -- ^ the prefix
                -> String       -- ^ the string
                -> Maybe String
getRestIfPrefix (p:ps) (x:xs) = if p==x then getRestIfPrefix ps xs else Nothing
getRestIfPrefix [] rest = Just rest
getRestIfPrefix _ [] = Nothing

subStr :: String                -- ^ the search string
       -> String                -- ^ the string to be searched
       -> Maybe (String,String) -- ^ Just (pre,post) if string is found
subStr sstr str = case (getRestIfPrefix sstr str, str) of
    (Just rest, _) -> Just ("",rest)
    (Nothing, "") -> Nothing
    (Nothing, strHead:strTail) -> do
        (pre, post) <- subStr sstr strTail
        Just (strHead:pre, post)

replaceMultiVars ::
    [(String,String)] -- ^ pairs of variable name and content
    -> String         -- ^ string to be searched
    -> String         -- ^ the result
replaceMultiVars [] str = str
replaceMultiVars whole@((pname,cont):rest) str = case subStr cont str of
    Nothing -> replaceMultiVars rest str
    Just (pre,post) -> (replaceMultiVars rest pre)++pname++(replaceMultiVars whole post)
