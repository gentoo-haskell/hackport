{-|
Module      : Portage.EBuild
License     : GPL-3+
Maintainer  : haskell@gentoo.org

Functions and types related to interpreting and manipulating an ebuild,
as understood by the Portage package manager.
-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE OverloadedStrings #-}

-- Needed to get OverloadedStrings to work
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}

module Portage.EBuild
        ( EBuild(..)
        , ebuildTemplate
        , showEBuild
        -- hspec exports
        , sort_iuse
        , drop_tdot
        , toHttps
        ) where

import           Portage.Dependency
import           Portage.EBuild.CabalFeature
import           Portage.EBuild.Render
import qualified Portage.Dependency.Normalize as PN

import qualified Data.Time.Clock as TC
import qualified Data.Time.Format as TC
import qualified Data.Function as F
import qualified Data.List as L
import qualified Data.List.Split as LS
import           Data.Version(Version(..))
import           Control.Monad.Trans.Writer.CPS
import           Data.Foldable (toList)
import           Data.Maybe (catMaybes)
import           Data.Monoid (Endo(..)) -- more efficient list concat
import           Hackport.Pretty
import           GHC.Exts (IsString(..))

import           Network.URI
import qualified Paths_hackport(version)

#if ! MIN_VERSION_time(1,5,0)
import qualified System.Locale as TC
#endif

-- | Type representing the information contained in an @.ebuild@.
data EBuild = EBuild
    { name :: String
    , category :: String
    , hackage_name :: String -- might differ a bit (we mangle case)
    , version :: String
    , revision :: String
    , hackportVersion :: String
    , sourceURIs :: [String]
    , description :: String
    , homepage :: String
    , license :: Either String String
    , slot :: String
    , keywords :: [String]
    , iuse :: [String]
    , depend :: Dependency
    , depend_extra :: [String]
    , rdepend :: Dependency
    , rdepend_extra :: [String]
    , features :: [CabalFeature]
    , cabal_pn :: Maybe String -- ^ Just 'myOldName' if the package name contains upper characters
    , src_prepare :: [String] -- ^ raw block for src_prepare() contents
    , src_configure :: [String] -- ^ raw block for src_configure() contents
    , used_options :: [(String, String)] -- ^ hints to ebuild writers/readers
                                         --   on what hackport options were used to produce an ebuild
    }
    deriving (Show, Read, Eq)

getHackportVersion :: Version -> String
getHackportVersion Version {versionBranch=(x:s)} = foldl (\y z -> y ++ "." ++ (show z)) (show x) s
getHackportVersion Version {versionBranch=[]} = ""

-- | Generate a minimal 'EBuild' template.
ebuildTemplate :: EBuild
ebuildTemplate = EBuild {
    name = "foobar",
    category = "dev-haskell",
    hackage_name = "FooBar",
    version = "0.1",
    revision = "0",
    sourceURIs = [],
    hackportVersion = getHackportVersion Paths_hackport.version,
    description = "",
    homepage = "https://hackage.haskell.org/package/${HACKAGE_N}",
    license = Left "unassigned license?",
    slot = "0",
    keywords = [],
    iuse = [],
    depend = empty_dependency,
    depend_extra = [],
    rdepend = empty_dependency,
    rdepend_extra = [],
    features = [],
    cabal_pn = Nothing
    , src_prepare = []
    , src_configure = []
    , used_options = []
  }

-- | Pretty-print an 'EBuild' as a 'String'.
showEBuild :: TC.UTCTime -> EBuild -> String
showEBuild now ebuild = replaceLeadingSpaces $ renderDoc $ execLinesBuilder $ do
    fromDoc $ "# Copyright 1999-" <> this_year <> " Gentoo Authors"
    "# Distributed under the terms of the GNU General Public License v2"
    emptyLine
    "EAPI=8"
    emptyLine
    fromDoc $ "# ebuild generated by hackport" <+> pretty (hackportVersion ebuild)
    let optLine (k,v) = "#hackport: " <> pretty k <> ": " <> pretty v
    fromDocs $ map optLine (used_options ebuild)
    emptyLine
    preFeatures
    fromDoc $ "CABAL_FEATURES=" <> dquotes (hsep (map (pretty . render) (features ebuild)))
    "inherit haskell-cabal"
    emptyLine
    fromDoc $ "DESCRIPTION=" <> dquotes (pretty (drop_tdot (description ebuild)))
    fromDoc $ "HOMEPAGE=" <> dquotes (pretty (toHttps (expandVars (homepage ebuild))))
    emptyLine
    fromDoc $ "LICENSE=" <> (either (\err -> dquotes emptyDoc <> "\t# FIXME: " <> pretty err)
                                    (dquotes . pretty)
                                    (license ebuild) )
    fromDoc $ "SLOT=" <> dquotes (pretty (slot ebuild))
    fromDoc $ "KEYWORDS=" <> dquotes (hsep (map pretty (keywords ebuild)))
    fromDocs $
      if null (iuse ebuild)
        then Nothing
        else
          let iuseList = hsep $ map pretty $ sort_iuse $ L.nub $ iuse ebuild
          in Just $ "IUSE=" <> dquotes iuseList
    emptyLine
    dep_str "RDEPEND" (rdepend_extra ebuild) (rdepend ebuild)
    dep_str "DEPEND"  ( depend_extra ebuild) ( depend ebuild)
    verbatim
      (vsep [emptyDoc, "src_prepare() {"])
      (map pretty (src_prepare ebuild))
      "}"
    verbatim
      (vsep [emptyDoc, "src_configure() {"])
      (map pretty (src_configure ebuild))
      "}"
  where
        expandVars = replaceMultiVars [ (        name ebuild, "${PN}")
                                      , (hackage_name ebuild, "${HACKAGE_N}")
                                      ]

        this_year :: Doc ann
        this_year = pretty $ TC.formatTime TC.defaultTimeLocale "%Y" now

        preFeatures =
            let rev = revLine (revision ebuild)
                pn = pnLine <$> cabal_pn ebuild
                preList = catMaybes [rev, pn]
            in if null preList
                  then pure ()
                  else fromDocs $ preList ++ [emptyDoc]

        revLine "0" = Nothing
        revLine r   = Just $ "CABAL_HACKAGE_REVISION=" <> pretty r

        pnLine pn = "CABAL_PN=" <> dquotes (pretty pn)

-- | Convert http urls into https urls, unless whitelisted as http-only.
--
-- >>> toHttps "http://darcs.net"
-- "http://darcs.net"
-- >>> toHttps "http://pandoc.org"
-- "https://pandoc.org"
-- >>> toHttps "https://github.com"
-- "https://github.com"
toHttps :: String -> String
toHttps x =
  case parseURI x of
    Just uri -> if uriScheme uri == "http:" &&
                   (uriRegName <$> uriAuthority uri)
                   `notElem`
                   httpOnlyHomepages
                then replace "http" "https" x
                else x
    Nothing -> x
  where
    replace old new = L.intercalate new . LS.splitOn old
    -- add to this list with any non https-aware websites
    httpOnlyHomepages = Just <$> [ "leksah.org"
                                 , "darcs.net"
                                 ]

-- | Sort IUSE alphabetically
--
-- >>> sort_iuse ["+a","b"]
-- ["+a","b"]
sort_iuse :: [String] -> [String]
sort_iuse = L.sortBy (compare `F.on` dropWhile ( `elem` ("+" :: String)))

-- | Drop trailing dot(s).
--
-- >>> drop_tdot "foo."
-- "foo"
-- >>> drop_tdot "foo..."
-- "foo"
drop_tdot :: String -> String
drop_tdot = reverse . dropWhile (== '.') . reverse

-- | Print the @pre@ line, each line in the list and the @post@ line, _only_
-- if the list is not empty.
verbatim :: Doc ann -> [Doc ann] -> Doc ann -> LinesBuilder ann ()
verbatim pre s post
  | null s = pure ()
  | otherwise = fromDocs $ [pre] ++ s ++ [post]

dep_str :: Doc ann -> [String] -> Dependency -> LinesBuilder ann ()
dep_str var extra dep = fromDoc $ vsep
    [ var <> "=\""
    , indent 1 (
        vsep (map pretty extra ++ [showDepend (PN.normalize_depend dep)])
      )
    , "\""
    ]

getRestIfPrefix :: String       -- ^ the prefix
                -> String       -- ^ the string
                -> Maybe String
getRestIfPrefix (p:ps) (x:xs) = if p==x then getRestIfPrefix ps xs else Nothing
getRestIfPrefix [] rest = Just rest
getRestIfPrefix _ [] = Nothing

subStr :: String                -- ^ the search string
       -> String                -- ^ the string to be searched
       -> Maybe (String,String) -- ^ Just (pre,post) if string is found
subStr sstr str = case (getRestIfPrefix sstr str, str) of
    (Just rest, _) -> Just ("",rest)
    (Nothing, "") -> Nothing
    (Nothing, strHead:strTail) -> do
        (pre, post) <- subStr sstr strTail
        Just (strHead:pre, post)

replaceMultiVars ::
    [(String,String)] -- ^ pairs of variable name and content
    -> String         -- ^ string to be searched
    -> String         -- ^ the result
replaceMultiVars [] str = str
replaceMultiVars whole@((pname,cont):rest) str = case subStr cont str of
    Nothing -> replaceMultiVars rest str
    Just (pre,post) -> (replaceMultiVars rest pre)++pname++(replaceMultiVars whole post)


emptyLine :: LinesBuilder ann ()
emptyLine = fromDoc emptyDoc

fromDoc :: Doc ann -> LinesBuilder ann ()
fromDoc = fromDocs . (:[])

fromDocs :: Foldable t => t (Doc ann) -> LinesBuilder ann ()
fromDocs = LinesBuilder . tell . Endo . (\x -> (toList x ++))

-- | Builds up a list of @prettyprinter@ 'Doc's and then concats them with
--   'vcat'. It is helpful for when a logical piece of the ebuild may use a
--   variable number of lines, including no lines at all.
--
--   Since it is a 'Monad', it can be used in a @do@ block.
--
--   Uses 'Endo' internally for more efficient list concats
newtype LinesBuilder ann a = LinesBuilder (Writer (Endo [Doc ann]) a)
    deriving (Functor, Applicative, Monad)

-- TypeFamilies/TypeOperators needs to be used here otherwise we get errors
-- when we go try to use OverloadedStrings
instance (a ~ ()) => IsString (LinesBuilder ann a) where
    fromString = fromDoc . fromString

execLinesBuilder :: LinesBuilder ann a -> Doc ann
execLinesBuilder (LinesBuilder w) = vsep (appEndo (execWriter w) [])

-- | Replace any leading spaces on each line with tabs
replaceLeadingSpaces :: String -> String
replaceLeadingSpaces = unlines . map go . lines
  where
    go (' ' : rest) = '\t' : go rest
    go rest = rest

